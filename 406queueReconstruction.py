# -*- coding: utf-8 -*-
"""
Created on Thu Feb 27 15:51:48 2020

@author: liuga
"""
#先确定高度高的 类似于135分糖果？ 时间复杂度O(n*logn + n^2)
class Solution(object):
    def queueReconstruction(self, people):
        
        people.sort(key = lambda x:(-x[0], x[1])) #从高到低排序？
        res = []
        for p in people:
            res.insert(p[1],p)
        return res
    
        
'''
手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心，


先排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]
插入的过程： 插入[7,0]：[[7,0]] 插入[7,1]：[[7,0],[7,1]] 插入[6,1]：[[7,0],[6,1],[7,1]]
插入[5,0]：[[5,0],[7,0],[6,1],[7,1]] 插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]
插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

